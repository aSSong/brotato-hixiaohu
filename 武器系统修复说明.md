# 武器系统修复说明

## 问题列表

### 1. ✅ 【重要】所有武器显示相同（共享资源问题）
**现象**：
- 初始2把武器（机枪+陨石）→ 显示为2把陨石
- 购买步枪 → 变成3把步枪
- Ghost复活后 → 所有5把武器都变成陨石

**原因**：多个武器实例共享同一个 `SpriteFrames` 资源对象

**解决方案**：每个武器实例创建独立的 `SpriteFrames`

**修复前**：
```gdscript
// 检查并重用现有的 SpriteFrames（错误！）
if not weaponAni.sprite_frames:
    weaponAni.sprite_frames = SpriteFrames.new()
var sprite_frames = weaponAni.sprite_frames  // 多个实例共享同一个对象
```

**修复后**：
```gdscript
// 总是创建新的 SpriteFrames（正确！）
var sprite_frames = SpriteFrames.new()  // 每个实例独立
weaponAni.sprite_frames = sprite_frames
```

**Godot 资源共享说明**：
- 从场景实例化的节点，其资源（如 SpriteFrames、Material）默认是共享的
- 修改共享资源会影响所有使用该资源的实例
- 解决方案：使用 `duplicate()` 或创建新实例

### 2. ✅ 武器类型显示错误
**原因**：WeaponFactory 在 set_script 后立即调用 initialize，但此时 @onready 节点引用还未准备好
**解决方案**：改回使用 meta 传递数据，让武器的 `_ready()` 函数处理初始化

**修复前的流程**：
```gdscript
1. WeaponFactory.create_weapon()
2. set_script() - 设置武器类型脚本
3. initialize() - 立即初始化（此时@onready节点可能未准备好）
4. 返回武器实例
5. add_child() - 添加到场景树
6. _ready() - 执行ready（但没有数据可用）
```

**修复后的流程**：
```gdscript
1. WeaponFactory.create_weapon()
2. set_script() - 设置武器类型脚本
3. set_meta() - 存储weapon_data和level
4. 返回武器实例
5. add_child() - 添加到场景树
6. _ready() - 执行ready，检测到meta，调用initialize()
7. initialize() - 此时@onready节点已准备好
```

### 3. ✅ 复活Ghost时报错 "previously freed"
**原因**：尝试访问已释放的weapon_instance
**解决方案**：
- 添加 `is_instance_valid()` 检查
- 添加 `has("weapon_data")` 检查
- 添加警告日志帮助调试

**修复代码**：
```gdscript
# 检查武器实例是否仍然有效
if not is_instance_valid(weapon_instance):
    push_error("[NowWeapons] 武器实例在添加后变为无效")
    return

# 应用职业加成（检查weapon_data是否存在）
if weapon_instance.has("weapon_data") and weapon_instance.weapon_data:
    _apply_class_bonuses(weapon_instance, weapon_instance.weapon_data)
else:
    push_warning("[NowWeapons] 武器实例的weapon_data未初始化")
```

## 修改的文件

### 1. Scripts/systems/weapons/weapon_factory.gd
**变更**：改回使用 meta 方式传递数据

**之前**：
```gdscript
weapon_instance.set_script(script)
weapon_instance.initialize(weapon_data, level)  # 直接调用
return weapon_instance
```

**现在**：
```gdscript
weapon_instance.set_script(script)
weapon_instance.set_meta("weapon_data", weapon_data)  # 使用meta
weapon_instance.set_meta("weapon_level", level)
return weapon_instance
```

### 2. Scripts/weapons/now_weapons.gd
**变更**：添加安全检查

**添加的检查**：
1. `is_instance_valid(weapon_instance)` - 确保对象未被释放
2. `has("weapon_data")` - 确保属性存在
3. `weapon_instance.weapon_data` - 确保数据非空
4. 添加警告日志

## 为什么使用meta方式

### 优点
1. ✅ **时序正确**：_ready() 执行时所有 @onready 节点已准备好
2. ✅ **向后兼容**：base_weapon.gd 的 _ready() 已经设计好处理 meta
3. ✅ **减少错误**：避免在节点未准备好时访问它们

### 缺点
1. ❌ 使用meta不够直观
2. ❌ 需要在 _ready() 中手动清理meta

### 为什么不直接调用 initialize()？

当使用 `set_script()` 更改脚本时，对象会经历一个重新初始化的过程。此时：
- @onready 变量还未赋值
- 子节点引用不可用
- 立即调用 initialize() 会访问 null 引用

## 测试建议

### 测试 1：武器创建
1. 开始新游戏
2. 选择射手职业（rifle + meteor）
3. 确认两把武器显示正确
4. 确认武器大小正常

### 测试 2：Ghost复活
1. 开始游戏
2. 故意死亡
3. 选择复活
4. 确认Ghost武器正确创建
5. 确认没有 "previously freed" 错误

### 测试 3：商店购买武器
1. 打开商店
2. 购买新武器
3. 确认武器正确添加
4. 确认武器显示正确

## 日志关键字

修复后，关注这些日志：
- ✅ `[WeaponFactory]` - 武器工厂创建日志
- ✅ `[NowWeapons]` - 武器添加日志
- ⚠️ `武器实例的weapon_data未初始化` - 表示初始化问题
- ❌ `武器实例在添加后变为无效` - 表示对象被提前释放

## Godot 资源共享深度解析

### 为什么会共享资源？

在 Godot 中，当你从 `.tscn` 场景文件实例化节点时：
```gdscript
var weapon = weapon_scene.instantiate()  // 从 weapon.tscn 实例化
```

节点会被复制，但节点引用的**资源**（Resource）默认是共享的：
- ✅ **节点**：每个实例独立（Node, Node2D 等）
- ❌ **资源**：多个实例共享（Texture, Material, SpriteFrames 等）

### 常见的共享资源陷阱

1. **SpriteFrames**（本次问题）
2. **ShaderMaterial**（修改 shader 参数时）
3. **AudioStream**（修改音频属性时）
4. **AnimationPlayer 的 Animation**

### 解决方案对比

#### 方案 1：创建新资源（推荐，简单）
```gdscript
var sprite_frames = SpriteFrames.new()  // ✅ 总是创建新的
weaponAni.sprite_frames = sprite_frames
```

#### 方案 2：复制现有资源
```gdscript
var sprite_frames = weaponAni.sprite_frames.duplicate()  // ✅ 复制一份
weaponAni.sprite_frames = sprite_frames
```

#### 方案 3：在场景中设置 "Local to Scene"
在 Godot 编辑器中，选择资源 → 右键 → "Make Local to Scene"
这会让每个实例自动获得独立的资源副本。

### 本项目采用的方案

**采用方案 1**：总是创建新的 SpriteFrames
- ✅ 简单直接
- ✅ 避免共享问题
- ✅ 代码清晰易懂
- ⚠️ 略微多一点内存（可忽略）

## 后续改进建议

如果未来想完全移除 meta 方式，可以考虑：
1. 将 initialize() 改为接受可选的 weapon_data 参数
2. 在 _ready() 中检查 weapon_data 是否为 null
3. WeaponFactory 返回前不调用 initialize
4. 调用者在 add_child 后手动调用 initialize

但当前的 meta 方式已经工作良好且向后兼容。

